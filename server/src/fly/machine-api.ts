// @ts-nocheck
/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export interface App {
  id?: string;
  name?: string;
  organization?: Organization;
  status?: string;
}

export interface CheckStatus {
  name?: string;
  output?: string;
  status?: string;
  updated_at?: string;
}

export interface CreateAppRequest {
  app_name?: string;
  app_role_id?: string;
  network?: string;
  org_slug?: string;
}

export interface CreateLeaseRequest {
  description?: string;
  ttl?: number;
}

export interface CreateMachineRequest {
  /** An object defining the Machine configuration */
  config?: ApiMachineConfig;
  lease_ttl?: number;
  lsvd?: boolean;
  /** Unique name for this Machine. If omitted, one is generated for you */
  name?: string;
  /** The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you). */
  region?: string;
  skip_launch?: boolean;
  skip_service_registration?: boolean;
}

export interface CreateVolumeRequest {
  compute?: ApiMachineGuest;
  encrypted?: boolean;
  fstype?: string;
  machines_only?: boolean;
  name?: string;
  region?: string;
  require_unique_zone?: boolean;
  size_gb?: number;
  /** restore from snapshot */
  snapshot_id?: string;
  snapshot_retention?: number;
  /** fork from remote volume */
  source_volume_id?: string;
}

export interface ErrorResponse {
  /** Deprecated */
  details?: any;
  error?: string;
  status?: MainStatusCode;
}

export interface ExtendVolumeRequest {
  size_gb?: number;
}

export interface ExtendVolumeResponse {
  needs_restart?: boolean;
  volume?: Volume;
}

export interface ImageRef {
  digest?: string;
  labels?: Record<string, string>;
  registry?: string;
  repository?: string;
  tag?: string;
}

export interface Lease {
  /** Description or reason for the Lease. */
  description?: string;
  /** ExpiresAt is the unix timestamp in UTC to denote when the Lease will no longer be valid. */
  expires_at?: number;
  /** Nonce is the unique ID autogenerated and associated with the Lease. */
  nonce?: string;
  /** Owner is the user identifier which acquired the Lease. */
  owner?: string;
  /** Machine version */
  version?: string;
}

export interface ListApp {
  id?: string;
  machine_count?: number;
  name?: string;
  network?: any;
}

export interface ListAppsResponse {
  apps?: ListApp[];
  total_apps?: number;
}

export interface ListenSocket {
  address?: string;
  proto?: string;
}

export interface Machine {
  checks?: CheckStatus[];
  config?: ApiMachineConfig;
  created_at?: string;
  events?: MachineEvent[];
  id?: string;
  image_ref?: ImageRef;
  /** InstanceID is unique for each version of the machine */
  instance_id?: string;
  name?: string;
  /** Nonce is only every returned on machine creation if a lease_duration was provided. */
  nonce?: string;
  /** PrivateIP is the internal 6PN address of the machine. */
  private_ip?: string;
  region?: string;
  state?: string;
  updated_at?: string;
}

export interface MachineEvent {
  id?: string;
  request?: any;
  source?: string;
  status?: string;
  timestamp?: number;
  type?: string;
}

export interface MachineExecRequest {
  /** Deprecated: use Command instead */
  cmd?: string;
  command?: string[];
  timeout?: number;
}

export interface MachineVersion {
  user_config?: ApiMachineConfig;
  version?: string;
}

export interface Organization {
  name?: string;
  slug?: string;
}

export interface ProcessStat {
  command?: string;
  cpu?: number;
  directory?: string;
  listen_sockets?: ListenSocket[];
  pid?: number;
  rss?: number;
  rtime?: number;
  stime?: number;
}

export interface SignalRequest {
  signal?: SignalRequestSignalEnum;
}

export interface StopRequest {
  signal?: string;
  timeout?: string;
}

export interface UpdateMachineRequest {
  /** An object defining the Machine configuration */
  config?: ApiMachineConfig;
  current_version?: string;
  lease_ttl?: number;
  lsvd?: boolean;
  /** Unique name for this Machine. If omitted, one is generated for you */
  name?: string;
  /** The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you). */
  region?: string;
  skip_launch?: boolean;
  skip_service_registration?: boolean;
}

export interface UpdateVolumeRequest {
  snapshot_retention?: number;
}

export interface Volume {
  attached_alloc_id?: string;
  attached_machine_id?: string;
  block_size?: number;
  blocks?: number;
  blocks_avail?: number;
  blocks_free?: number;
  created_at?: string;
  encrypted?: boolean;
  fstype?: string;
  id?: string;
  name?: string;
  region?: string;
  size_gb?: number;
  snapshot_retention?: number;
  state?: string;
  zone?: string;
}

export interface VolumeSnapshot {
  created_at?: string;
  digest?: string;
  id?: string;
  size?: number;
  status?: string;
}

export interface ApiDNSConfig {
  nameservers?: string[];
  options?: ApiDnsOption[];
  searches?: string[];
  skip_registration?: boolean;
}

/** A file that will be written to the Machine. One of RawValue or SecretName must be set. */
export interface ApiFile {
  /**
   * GuestPath is the path on the machine where the file will be written and must be an absolute path.
   * For example: /full/path/to/file.json
   */
  guest_path?: string;
  /** The base64 encoded string of the file contents. */
  raw_value?: string;
  /** The name of the secret that contains the base64 encoded file contents. */
  secret_name?: string;
}

export interface ApiHTTPOptions {
  compress?: boolean;
  h2_backend?: boolean;
  response?: ApiHTTPResponseOptions;
}

export interface ApiHTTPResponseOptions {
  headers?: Record<string, any>;
}

/** An optional object that defines one or more named checks. The key for each check is the check name. */
export interface ApiMachineCheck {
  /** The time to wait after a VM starts before checking its health */
  grace_period?: string;
  headers?: ApiMachineHTTPHeader[];
  /** The time between connectivity checks */
  interval?: string;
  /** For http checks, the HTTP method to use to when making the request */
  method?: string;
  /** For http checks, the path to send the request to */
  path?: string;
  /** The port to connect to, often the same as internal_port */
  port?: number;
  /** For http checks, whether to use http or https */
  protocol?: string;
  /** The maximum time a connection can take before being reported as failing its health check */
  timeout?: string;
  /** If the protocol is https, the hostname to use for TLS certificate validation */
  tls_server_name?: string;
  /** For http checks with https protocol, whether or not to verify the TLS certificate */
  tls_skip_verify?: boolean;
  /** tcp or http */
  type?: string;
}

export interface ApiMachineConfig {
  /** Optional boolean telling the Machine to destroy itself once it’s complete (default false) */
  auto_destroy?: boolean;
  checks?: Record<string, ApiMachineCheck>;
  /** Deprecated: use Service.Autostart instead */
  disable_machine_autostart?: boolean;
  dns?: ApiDNSConfig;
  /** An object filled with key/value pairs to be set as environment variables */
  env?: Record<string, string>;
  files?: ApiFile[];
  guest?: ApiMachineGuest;
  /** The docker image to run */
  image?: string;
  init?: ApiMachineInit;
  metadata?: Record<string, string>;
  metrics?: ApiMachineMetrics;
  mounts?: ApiMachineMount[];
  processes?: ApiMachineProcess[];
  /** The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/. */
  restart?: ApiMachineRestart;
  schedule?: string;
  services?: ApiMachineService[];
  /** Deprecated: use Guest instead */
  size?: string;
  /**
   * Standbys enable a machine to be a standby for another. In the event of a hardware failure,
   * the standby machine will be started.
   */
  standbys?: string[];
  statics?: ApiStatic[];
  stop_config?: ApiStopConfig;
}

export interface ApiMachineGuest {
  cpu_kind?: string;
  cpus?: number;
  gpu_kind?: string;
  host_dedication_id?: string;
  kernel_args?: string[];
  memory_mb?: number;
}

/** For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call. */
export interface ApiMachineHTTPHeader {
  /** The header name */
  name?: string;
  /** The header value */
  values?: string[];
}

export interface ApiMachineInit {
  cmd?: string[];
  entrypoint?: string[];
  exec?: string[];
  kernel_args?: string[];
  swap_size_mb?: number;
  tty?: boolean;
}

export interface ApiMachineMetrics {
  path?: string;
  port?: number;
}

export interface ApiMachineMount {
  add_size_gb?: number;
  encrypted?: boolean;
  extend_threshold_percent?: number;
  name?: string;
  path?: string;
  size_gb?: number;
  size_gb_limit?: number;
  volume?: string;
}

export interface ApiMachinePort {
  end_port?: number;
  force_https?: boolean;
  handlers?: string[];
  http_options?: ApiHTTPOptions;
  port?: number;
  proxy_proto_options?: ApiProxyProtoOptions;
  start_port?: number;
  tls_options?: ApiTLSOptions;
}

export interface ApiMachineProcess {
  cmd?: string[];
  entrypoint?: string[];
  env?: Record<string, string>;
  exec?: string[];
  user?: string;
}

/** The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/. */
export interface ApiMachineRestart {
  /** When policy is on-failure, the maximum number of times to attempt to restart the Machine before letting it stop. */
  max_retries?: number;
  /**
   * * no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.
   * * always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.
   * * on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.
   */
  policy?: ApiMachineRestartPolicyEnum;
}

export interface ApiMachineService {
  autostart?: boolean;
  autostop?: boolean;
  checks?: ApiMachineCheck[];
  concurrency?: ApiMachineServiceConcurrency;
  force_instance_description?: string;
  force_instance_key?: string;
  internal_port?: number;
  min_machines_running?: number;
  ports?: ApiMachinePort[];
  protocol?: string;
}

export interface ApiMachineServiceConcurrency {
  hard_limit?: number;
  soft_limit?: number;
  type?: string;
}

export interface ApiProxyProtoOptions {
  version?: string;
}

export interface ApiStatic {
  guest_path: string;
  url_prefix: string;
}

export interface ApiStopConfig {
  signal?: string;
  timeout?: string;
}

export interface ApiTLSOptions {
  alpn?: string[];
  default_self_signed?: boolean;
  versions?: string[];
}

export interface ApiDnsOption {
  name?: string;
  value?: string;
}

export enum MainStatusCode {
  Unknown = "unknown",
  CapacityErr = "insufficient_capacity",
}

export enum SignalRequestSignalEnum {
  SIGABRT = "SIGABRT",
  SIGALRM = "SIGALRM",
  SIGFPE = "SIGFPE",
  SIGHUP = "SIGHUP",
  SIGILL = "SIGILL",
  SIGINT = "SIGINT",
  SIGKILL = "SIGKILL",
  SIGPIPE = "SIGPIPE",
  SIGQUIT = "SIGQUIT",
  SIGSEGV = "SIGSEGV",
  SIGTERM = "SIGTERM",
  SIGTRAP = "SIGTRAP",
  SIGUSR1 = "SIGUSR1",
}

/**
 * * no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.
 * * always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.
 * * on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.
 */
export enum ApiMachineRestartPolicyEnum {
  No = "no",
  Always = "always",
  OnFailure = "on-failure",
}

export interface AppsListParams {
  /** The org slug, or 'personal', to filter apps */
  org_slug: string;
}

export type AppsListData = ListAppsResponse;

export type AppsCreateData = any;

export type AppsShowData = App;

export type AppsDeleteData = any;

export interface MachinesListParams {
  /** Include deleted machines */
  include_deleted?: boolean;
  /** Region filter */
  region?: string;
  /** Fly App Name */
  appName: string;
}

export type MachinesListData = Machine[];

export type MachinesCreateData = Machine;

export type MachinesShowData = Machine;

export type MachinesUpdateData = Machine;

export type MachinesDeleteData = any;

export type MachinesCordonData = any;

export type MachinesListEventsData = MachineEvent[];

export type MachinesExecData = string;

export type MachinesShowLeaseData = Lease;

export type MachinesCreateLeaseData = Lease;

export type MachinesReleaseLeaseData = any;

export type MachinesShowMetadataData = Record<string, string>;

export type MachinesUpdateMetadataData = any;

export type MachinesDeleteMetadataData = any;

export interface MachinesListProcessesParams {
  /** Sort by */
  sort_by?: string;
  /** Order */
  order?: string;
  /** Fly App Name */
  appName: string;
  /** Machine ID */
  machineId: string;
}

export type MachinesListProcessesData = ProcessStat[];

export interface MachinesRestartParams {
  /** Restart timeout as a Go duration string or number of seconds */
  timeout?: string;
  /** Fly App Name */
  appName: string;
  /** Machine ID */
  machineId: string;
}

export type MachinesRestartData = any;

export type MachinesSignalData = any;

export type MachinesStartData = any;

export type MachinesStopData = any;

export type MachinesUncordonData = any;

export type MachinesListVersionsData = MachineVersion[];

export interface MachinesWaitParams {
  /** instance? version? TODO */
  instance_id?: string;
  /** wait timeout. default 60s */
  timeout?: number;
  /** desired state */
  state?: StateEnum;
  /** Fly App Name */
  appName: string;
  /** Machine ID */
  machineId: string;
}

/** desired state */
export enum StateEnum {
  Started = "started",
  Stopped = "stopped",
  Destroyed = "destroyed",
}

export type MachinesWaitData = any;

/** desired state */
export enum MachinesWaitParams1StateEnum {
  Started = "started",
  Stopped = "stopped",
  Destroyed = "destroyed",
}

export type VolumesListData = Volume[];

export type VolumesCreateData = Volume;

export type VolumesGetByIdData = Volume;

export type VolumesUpdateData = Volume;

export type VolumeDeleteData = Volume;

export type VolumesExtendData = ExtendVolumeResponse;

export type VolumesListSnapshotsData = VolumeSnapshot[];

export type CreateVolumeSnapshotData = any;

export namespace Apps {
  /**
   * No description
   * @tags Apps
   * @name AppsList
   * @request GET:/apps
   * @response `200` `AppsListData` OK
   */
  export namespace AppsList {
    export type RequestParams = {};
    export type RequestQuery = {
      /** The org slug, or 'personal', to filter apps */
      org_slug: string;
    };
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = AppsListData;
  }
  /**
   * No description
   * @tags Apps
   * @name AppsCreate
   * @request POST:/apps
   * @response `201` `AppsCreateData` Created
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace AppsCreate {
    export type RequestParams = {};
    export type RequestQuery = {};
    export type RequestBody = CreateAppRequest;
    export type RequestHeaders = {};
    export type ResponseBody = AppsCreateData;
  }
  /**
   * No description
   * @tags Apps
   * @name AppsShow
   * @request GET:/apps/{app_name}
   * @response `200` `AppsShowData` OK
   */
  export namespace AppsShow {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = AppsShowData;
  }
  /**
   * No description
   * @tags Apps
   * @name AppsDelete
   * @request DELETE:/apps/{app_name}
   * @response `202` `AppsDeleteData` Accepted
   */
  export namespace AppsDelete {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = AppsDeleteData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesList
   * @request GET:/apps/{app_name}/machines
   * @response `200` `MachinesListData` OK
   */
  export namespace MachinesList {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
    };
    export type RequestQuery = {
      /** Include deleted machines */
      include_deleted?: boolean;
      /** Region filter */
      region?: string;
    };
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesListData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesCreate
   * @request POST:/apps/{app_name}/machines
   * @response `200` `MachinesCreateData` OK
   */
  export namespace MachinesCreate {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
    };
    export type RequestQuery = {};
    export type RequestBody = CreateMachineRequest;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesCreateData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesShow
   * @request GET:/apps/{app_name}/machines/{machine_id}
   * @response `200` `MachinesShowData` OK
   */
  export namespace MachinesShow {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesShowData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesUpdate
   * @request POST:/apps/{app_name}/machines/{machine_id}
   * @response `200` `MachinesUpdateData` OK
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace MachinesUpdate {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = UpdateMachineRequest;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesUpdateData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesDelete
   * @request DELETE:/apps/{app_name}/machines/{machine_id}
   * @response `200` `MachinesDeleteData` OK
   */
  export namespace MachinesDelete {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesDeleteData;
  }
  /**
   * @description “Cordoning” a machine refers to disabling its services, so the proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of machines is started up with services disabled, and when they are all healthy, the services are enabled on the new machines and disabled on the old ones.
   * @tags Machines
   * @name MachinesCordon
   * @request POST:/apps/{app_name}/machines/{machine_id}/cordon
   * @response `200` `MachinesCordonData` OK
   */
  export namespace MachinesCordon {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesCordonData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesListEvents
   * @request GET:/apps/{app_name}/machines/{machine_id}/events
   * @response `200` `MachinesListEventsData` OK
   */
  export namespace MachinesListEvents {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesListEventsData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesExec
   * @request POST:/apps/{app_name}/machines/{machine_id}/exec
   * @response `200` `MachinesExecData` Raw command output bytes are written back
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace MachinesExec {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = MachineExecRequest;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesExecData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesShowLease
   * @request GET:/apps/{app_name}/machines/{machine_id}/lease
   * @response `200` `MachinesShowLeaseData` OK
   */
  export namespace MachinesShowLease {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesShowLeaseData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesCreateLease
   * @request POST:/apps/{app_name}/machines/{machine_id}/lease
   * @response `200` `MachinesCreateLeaseData` OK
   */
  export namespace MachinesCreateLease {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = CreateLeaseRequest;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesCreateLeaseData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesReleaseLease
   * @request DELETE:/apps/{app_name}/machines/{machine_id}/lease
   * @response `200` `MachinesReleaseLeaseData` OK
   */
  export namespace MachinesReleaseLease {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesReleaseLeaseData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesShowMetadata
   * @request GET:/apps/{app_name}/machines/{machine_id}/metadata
   * @response `200` `MachinesShowMetadataData` OK
   */
  export namespace MachinesShowMetadata {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesShowMetadataData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesUpdateMetadata
   * @request POST:/apps/{app_name}/machines/{machine_id}/metadata/{key}
   * @response `204` `MachinesUpdateMetadataData` No Content
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace MachinesUpdateMetadata {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
      /** Metadata Key */
      key: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesUpdateMetadataData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesDeleteMetadata
   * @request DELETE:/apps/{app_name}/machines/{machine_id}/metadata/{key}
   * @response `204` `MachinesDeleteMetadataData` No Content
   */
  export namespace MachinesDeleteMetadata {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
      /** Metadata Key */
      key: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesDeleteMetadataData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesListProcesses
   * @request GET:/apps/{app_name}/machines/{machine_id}/ps
   * @response `200` `MachinesListProcessesData` OK
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace MachinesListProcesses {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {
      /** Sort by */
      sort_by?: string;
      /** Order */
      order?: string;
    };
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesListProcessesData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesRestart
   * @request POST:/apps/{app_name}/machines/{machine_id}/restart
   * @response `200` `MachinesRestartData` OK
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace MachinesRestart {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {
      /** Restart timeout as a Go duration string or number of seconds */
      timeout?: string;
    };
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesRestartData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesSignal
   * @request POST:/apps/{app_name}/machines/{machine_id}/signal
   * @response `200` `MachinesSignalData` OK
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace MachinesSignal {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = SignalRequest;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesSignalData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesStart
   * @request POST:/apps/{app_name}/machines/{machine_id}/start
   * @response `200` `MachinesStartData` OK
   */
  export namespace MachinesStart {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesStartData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesStop
   * @request POST:/apps/{app_name}/machines/{machine_id}/stop
   * @response `200` `MachinesStopData` OK
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace MachinesStop {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = StopRequest;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesStopData;
  }
  /**
   * @description “Cordoning” a machine refers to disabling its services, so the proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of machines is started up with services disabled, and when they are all healthy, the services are enabled on the new machines and disabled on the old ones.
   * @tags Machines
   * @name MachinesUncordon
   * @request POST:/apps/{app_name}/machines/{machine_id}/uncordon
   * @response `200` `MachinesUncordonData` OK
   */
  export namespace MachinesUncordon {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesUncordonData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesListVersions
   * @request GET:/apps/{app_name}/machines/{machine_id}/versions
   * @response `200` `MachinesListVersionsData` OK
   */
  export namespace MachinesListVersions {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesListVersionsData;
  }
  /**
   * No description
   * @tags Machines
   * @name MachinesWait
   * @request GET:/apps/{app_name}/machines/{machine_id}/wait
   * @response `200` `MachinesWaitData` OK
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace MachinesWait {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Machine ID */
      machineId: string;
    };
    export type RequestQuery = {
      /** instance? version? TODO */
      instance_id?: string;
      /** wait timeout. default 60s */
      timeout?: number;
      /** desired state */
      state?: MachinesWaitParams1StateEnum;
    };
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = MachinesWaitData;
  }
  /**
   * No description
   * @tags Volumes
   * @name VolumesList
   * @request GET:/apps/{app_name}/volumes
   * @response `200` `VolumesListData` OK
   */
  export namespace VolumesList {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = VolumesListData;
  }
  /**
   * No description
   * @tags Volumes
   * @name VolumesCreate
   * @request POST:/apps/{app_name}/volumes
   * @response `200` `VolumesCreateData` OK
   */
  export namespace VolumesCreate {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
    };
    export type RequestQuery = {};
    export type RequestBody = CreateVolumeRequest;
    export type RequestHeaders = {};
    export type ResponseBody = VolumesCreateData;
  }
  /**
   * No description
   * @tags Volumes
   * @name VolumesGetById
   * @request GET:/apps/{app_name}/volumes/{volume_id}
   * @response `200` `VolumesGetByIdData` OK
   */
  export namespace VolumesGetById {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Volume ID */
      volumeId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = VolumesGetByIdData;
  }
  /**
   * No description
   * @tags Volumes
   * @name VolumesUpdate
   * @request POST:/apps/{app_name}/volumes/{volume_id}
   * @response `200` `VolumesUpdateData` OK
   * @response `400` `ErrorResponse` Bad Request
   */
  export namespace VolumesUpdate {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Volume ID */
      volumeId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = UpdateVolumeRequest;
    export type RequestHeaders = {};
    export type ResponseBody = VolumesUpdateData;
  }
  /**
   * No description
   * @tags Volumes
   * @name VolumeDelete
   * @request DELETE:/apps/{app_name}/volumes/{volume_id}
   * @response `200` `VolumeDeleteData` OK
   */
  export namespace VolumeDelete {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Volume ID */
      volumeId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = VolumeDeleteData;
  }
  /**
   * No description
   * @tags Volumes
   * @name VolumesExtend
   * @request PUT:/apps/{app_name}/volumes/{volume_id}/extend
   * @response `200` `VolumesExtendData` OK
   */
  export namespace VolumesExtend {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Volume ID */
      volumeId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = ExtendVolumeRequest;
    export type RequestHeaders = {};
    export type ResponseBody = VolumesExtendData;
  }
  /**
   * No description
   * @tags Volumes
   * @name VolumesListSnapshots
   * @request GET:/apps/{app_name}/volumes/{volume_id}/snapshots
   * @response `200` `VolumesListSnapshotsData` OK
   */
  export namespace VolumesListSnapshots {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Volume ID */
      volumeId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = VolumesListSnapshotsData;
  }
  /**
   * No description
   * @tags Volumes
   * @name CreateVolumeSnapshot
   * @request POST:/apps/{app_name}/volumes/{volume_id}/snapshots
   * @response `200` `CreateVolumeSnapshotData` OK
   */
  export namespace CreateVolumeSnapshot {
    export type RequestParams = {
      /** Fly App Name */
      appName: string;
      /** Volume ID */
      volumeId: string;
    };
    export type RequestQuery = {};
    export type RequestBody = never;
    export type RequestHeaders = {};
    export type ResponseBody = CreateVolumeSnapshotData;
  }
}

export type QueryParamsType = Record<string | number, any>;
export type ResponseFormat = keyof Omit<Body, "body" | "bodyUsed">;

export interface FullRequestParams extends Omit<RequestInit, "body"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseFormat;
  /** request body */
  body?: unknown;
  /** base url */
  baseUrl?: string;
  /** request cancellation token */
  cancelToken?: CancelToken;
}

export type RequestParams = Omit<
  FullRequestParams,
  "body" | "method" | "query" | "path"
>;

export interface ApiConfig<SecurityDataType = unknown> {
  baseUrl?: string;
  baseApiParams?: Omit<RequestParams, "baseUrl" | "cancelToken" | "signal">;
  securityWorker?: (
    securityData: SecurityDataType | null
  ) => Promise<RequestParams | void> | RequestParams | void;
  customFetch?: typeof fetch;
}

export interface HttpResponse<D extends unknown, E extends unknown = unknown>
  extends Response {
  data: D;
  error: E;
}

type CancelToken = Symbol | string | number;

export enum ContentType {
  Json = "application/json",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public baseUrl: string = "https://api.machines.dev/v1";
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private abortControllers = new Map<CancelToken, AbortController>();
  private customFetch = (...fetchParams: Parameters<typeof fetch>) =>
    fetch(...fetchParams);

  private baseApiParams: RequestParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer",
  };

  constructor(apiConfig: ApiConfig<SecurityDataType> = {}) {
    Object.assign(this, apiConfig);
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected encodeQueryParam(key: string, value: any) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(
      typeof value === "number" ? value : `${value}`
    )}`;
  }

  protected addQueryParam(query: QueryParamsType, key: string) {
    return this.encodeQueryParam(key, query[key]);
  }

  protected addArrayQueryParam(query: QueryParamsType, key: string) {
    const value = query[key];
    return value.map((v: any) => this.encodeQueryParam(key, v)).join("&");
  }

  protected toQueryString(rawQuery?: QueryParamsType): string {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter(
      (key) => "undefined" !== typeof query[key]
    );
    return keys
      .map((key) =>
        Array.isArray(query[key])
          ? this.addArrayQueryParam(query, key)
          : this.addQueryParam(query, key)
      )
      .join("&");
  }

  protected addQueryParams(rawQuery?: QueryParamsType): string {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }

  private contentFormatters: Record<ContentType, (input: any) => any> = {
    [ContentType.Json]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string")
        ? JSON.stringify(input)
        : input,
    [ContentType.Text]: (input: any) =>
      input !== null && typeof input !== "string"
        ? JSON.stringify(input)
        : input,
    [ContentType.FormData]: (input: any) =>
      Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(
          key,
          property instanceof Blob
            ? property
            : typeof property === "object" && property !== null
            ? JSON.stringify(property)
            : `${property}`
        );
        return formData;
      }, new FormData()),
    [ContentType.UrlEncoded]: (input: any) => this.toQueryString(input),
  };

  protected mergeRequestParams(
    params1: RequestParams,
    params2?: RequestParams
  ): RequestParams {
    return {
      ...this.baseApiParams,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...(this.baseApiParams.headers || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected createAbortSignal = (
    cancelToken: CancelToken
  ): AbortSignal | undefined => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController = this.abortControllers.get(cancelToken);
      if (abortController) {
        return abortController.signal;
      }
      return void 0;
    }

    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };

  public abortRequest = (cancelToken: CancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);

    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };

  public request = async <T = any, E = any>({
    body,
    secure,
    path,
    type,
    query,
    format,
    baseUrl,
    cancelToken,
    ...params
  }: FullRequestParams): Promise<HttpResponse<T, E>> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.baseApiParams.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;

    return this.customFetch(
      `${baseUrl || this.baseUrl || ""}${path}${
        queryString ? `?${queryString}` : ""
      }`,
      {
        ...requestParams,
        headers: {
          ...(requestParams.headers || {}),
          ...(type && type !== ContentType.FormData
            ? { "Content-Type": type }
            : {}),
        },
        signal:
          (cancelToken
            ? this.createAbortSignal(cancelToken)
            : requestParams.signal) || null,
        body:
          typeof body === "undefined" || body === null
            ? null
            : payloadFormatter(body),
      }
    ).then(async (response) => {
      const r = response as HttpResponse<T, E>;
      r.data = null as unknown as T;
      r.error = null as unknown as E;

      const data = !responseFormat
        ? r
        : await response[responseFormat]()
            .then((data) => {
              if (r.ok) {
                r.data = data;
              } else {
                r.error = data;
              }
              return r;
            })
            .catch((e) => {
              r.error = e;
              return r;
            });

      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }

      if (!response.ok) throw data;
      return data;
    });
  };
}

/**
 * @title Fly Machines API
 * @version 1.0
 * @license Apache 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html)
 * @baseUrl https://api.machines.dev/v1
 * @externalDocs https://fly.io/docs/machines/working-with-machines/
 * @contact
 */
export class Api<
  SecurityDataType extends unknown,
> extends HttpClient<SecurityDataType> {
  apps = {
    /**
     * No description
     *
     * @tags Apps
     * @name AppsList
     * @request GET:/apps
     * @response `200` `AppsListData` OK
     */
    appsList: (query: AppsListParams, params: RequestParams = {}) =>
      this.request<AppsListData, any>({
        path: `/apps`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsCreate
     * @request POST:/apps
     * @response `201` `AppsCreateData` Created
     * @response `400` `ErrorResponse` Bad Request
     */
    appsCreate: (request: CreateAppRequest, params: RequestParams = {}) =>
      this.request<AppsCreateData, ErrorResponse>({
        path: `/apps`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsShow
     * @request GET:/apps/{app_name}
     * @response `200` `AppsShowData` OK
     */
    appsShow: (appName: string, params: RequestParams = {}) =>
      this.request<AppsShowData, any>({
        path: `/apps/${appName}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Apps
     * @name AppsDelete
     * @request DELETE:/apps/{app_name}
     * @response `202` `AppsDeleteData` Accepted
     */
    appsDelete: (appName: string, params: RequestParams = {}) =>
      this.request<AppsDeleteData, any>({
        path: `/apps/${appName}`,
        method: "DELETE",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesList
     * @request GET:/apps/{app_name}/machines
     * @response `200` `MachinesListData` OK
     */
    machinesList: (
      { appName, ...query }: MachinesListParams,
      params: RequestParams = {}
    ) =>
      this.request<MachinesListData, any>({
        path: `/apps/${appName}/machines`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesCreate
     * @request POST:/apps/{app_name}/machines
     * @response `200` `MachinesCreateData` OK
     */
    machinesCreate: (
      appName: string,
      request: CreateMachineRequest,
      params: RequestParams = {}
    ) =>
      this.request<MachinesCreateData, any>({
        path: `/apps/${appName}/machines`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesShow
     * @request GET:/apps/{app_name}/machines/{machine_id}
     * @response `200` `MachinesShowData` OK
     */
    machinesShow: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesShowData, any>({
        path: `/apps/${appName}/machines/${machineId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesUpdate
     * @request POST:/apps/{app_name}/machines/{machine_id}
     * @response `200` `MachinesUpdateData` OK
     * @response `400` `ErrorResponse` Bad Request
     */
    machinesUpdate: (
      appName: string,
      machineId: string,
      request: UpdateMachineRequest,
      params: RequestParams = {}
    ) =>
      this.request<MachinesUpdateData, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesDelete
     * @request DELETE:/apps/{app_name}/machines/{machine_id}
     * @response `200` `MachinesDeleteData` OK
     */
    machinesDelete: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesDeleteData, any>({
        path: `/apps/${appName}/machines/${machineId}`,
        method: "DELETE",
        ...params,
      }),

    /**
     * @description “Cordoning” a machine refers to disabling its services, so the proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of machines is started up with services disabled, and when they are all healthy, the services are enabled on the new machines and disabled on the old ones.
     *
     * @tags Machines
     * @name MachinesCordon
     * @request POST:/apps/{app_name}/machines/{machine_id}/cordon
     * @response `200` `MachinesCordonData` OK
     */
    machinesCordon: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesCordonData, any>({
        path: `/apps/${appName}/machines/${machineId}/cordon`,
        method: "POST",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesListEvents
     * @request GET:/apps/{app_name}/machines/{machine_id}/events
     * @response `200` `MachinesListEventsData` OK
     */
    machinesListEvents: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesListEventsData, any>({
        path: `/apps/${appName}/machines/${machineId}/events`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesExec
     * @request POST:/apps/{app_name}/machines/{machine_id}/exec
     * @response `200` `MachinesExecData` Raw command output bytes are written back
     * @response `400` `ErrorResponse` Bad Request
     */
    machinesExec: (
      appName: string,
      machineId: string,
      request: MachineExecRequest,
      params: RequestParams = {}
    ) =>
      this.request<MachinesExecData, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/exec`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesShowLease
     * @request GET:/apps/{app_name}/machines/{machine_id}/lease
     * @response `200` `MachinesShowLeaseData` OK
     */
    machinesShowLease: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesShowLeaseData, any>({
        path: `/apps/${appName}/machines/${machineId}/lease`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesCreateLease
     * @request POST:/apps/{app_name}/machines/{machine_id}/lease
     * @response `200` `MachinesCreateLeaseData` OK
     */
    machinesCreateLease: (
      appName: string,
      machineId: string,
      request: CreateLeaseRequest,
      params: RequestParams = {}
    ) =>
      this.request<MachinesCreateLeaseData, any>({
        path: `/apps/${appName}/machines/${machineId}/lease`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesReleaseLease
     * @request DELETE:/apps/{app_name}/machines/{machine_id}/lease
     * @response `200` `MachinesReleaseLeaseData` OK
     */
    machinesReleaseLease: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesReleaseLeaseData, any>({
        path: `/apps/${appName}/machines/${machineId}/lease`,
        method: "DELETE",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesShowMetadata
     * @request GET:/apps/{app_name}/machines/{machine_id}/metadata
     * @response `200` `MachinesShowMetadataData` OK
     */
    machinesShowMetadata: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesShowMetadataData, any>({
        path: `/apps/${appName}/machines/${machineId}/metadata`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesUpdateMetadata
     * @request POST:/apps/{app_name}/machines/{machine_id}/metadata/{key}
     * @response `204` `MachinesUpdateMetadataData` No Content
     * @response `400` `ErrorResponse` Bad Request
     */
    machinesUpdateMetadata: (
      appName: string,
      machineId: string,
      key: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesUpdateMetadataData, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/metadata/${key}`,
        method: "POST",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesDeleteMetadata
     * @request DELETE:/apps/{app_name}/machines/{machine_id}/metadata/{key}
     * @response `204` `MachinesDeleteMetadataData` No Content
     */
    machinesDeleteMetadata: (
      appName: string,
      machineId: string,
      key: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesDeleteMetadataData, any>({
        path: `/apps/${appName}/machines/${machineId}/metadata/${key}`,
        method: "DELETE",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesListProcesses
     * @request GET:/apps/{app_name}/machines/{machine_id}/ps
     * @response `200` `MachinesListProcessesData` OK
     * @response `400` `ErrorResponse` Bad Request
     */
    machinesListProcesses: (
      { appName, machineId, ...query }: MachinesListProcessesParams,
      params: RequestParams = {}
    ) =>
      this.request<MachinesListProcessesData, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/ps`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesRestart
     * @request POST:/apps/{app_name}/machines/{machine_id}/restart
     * @response `200` `MachinesRestartData` OK
     * @response `400` `ErrorResponse` Bad Request
     */
    machinesRestart: (
      { appName, machineId, ...query }: MachinesRestartParams,
      params: RequestParams = {}
    ) =>
      this.request<MachinesRestartData, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/restart`,
        method: "POST",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesSignal
     * @request POST:/apps/{app_name}/machines/{machine_id}/signal
     * @response `200` `MachinesSignalData` OK
     * @response `400` `ErrorResponse` Bad Request
     */
    machinesSignal: (
      appName: string,
      machineId: string,
      request: SignalRequest,
      params: RequestParams = {}
    ) =>
      this.request<MachinesSignalData, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/signal`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesStart
     * @request POST:/apps/{app_name}/machines/{machine_id}/start
     * @response `200` `MachinesStartData` OK
     */
    machinesStart: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesStartData, any>({
        path: `/apps/${appName}/machines/${machineId}/start`,
        method: "POST",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesStop
     * @request POST:/apps/{app_name}/machines/{machine_id}/stop
     * @response `200` `MachinesStopData` OK
     * @response `400` `ErrorResponse` Bad Request
     */
    machinesStop: (
      appName: string,
      machineId: string,
      request: StopRequest,
      params: RequestParams = {}
    ) =>
      this.request<MachinesStopData, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/stop`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description “Cordoning” a machine refers to disabling its services, so the proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of machines is started up with services disabled, and when they are all healthy, the services are enabled on the new machines and disabled on the old ones.
     *
     * @tags Machines
     * @name MachinesUncordon
     * @request POST:/apps/{app_name}/machines/{machine_id}/uncordon
     * @response `200` `MachinesUncordonData` OK
     */
    machinesUncordon: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesUncordonData, any>({
        path: `/apps/${appName}/machines/${machineId}/uncordon`,
        method: "POST",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesListVersions
     * @request GET:/apps/{app_name}/machines/{machine_id}/versions
     * @response `200` `MachinesListVersionsData` OK
     */
    machinesListVersions: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachinesListVersionsData, any>({
        path: `/apps/${appName}/machines/${machineId}/versions`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Machines
     * @name MachinesWait
     * @request GET:/apps/{app_name}/machines/{machine_id}/wait
     * @response `200` `MachinesWaitData` OK
     * @response `400` `ErrorResponse` Bad Request
     */
    machinesWait: (
      { appName, machineId, ...query }: MachinesWaitParams,
      params: RequestParams = {}
    ) =>
      this.request<MachinesWaitData, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/wait`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Volumes
     * @name VolumesList
     * @request GET:/apps/{app_name}/volumes
     * @response `200` `VolumesListData` OK
     */
    volumesList: (appName: string, params: RequestParams = {}) =>
      this.request<VolumesListData, any>({
        path: `/apps/${appName}/volumes`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Volumes
     * @name VolumesCreate
     * @request POST:/apps/{app_name}/volumes
     * @response `200` `VolumesCreateData` OK
     */
    volumesCreate: (
      appName: string,
      request: CreateVolumeRequest,
      params: RequestParams = {}
    ) =>
      this.request<VolumesCreateData, any>({
        path: `/apps/${appName}/volumes`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Volumes
     * @name VolumesGetById
     * @request GET:/apps/{app_name}/volumes/{volume_id}
     * @response `200` `VolumesGetByIdData` OK
     */
    volumesGetById: (
      appName: string,
      volumeId: string,
      params: RequestParams = {}
    ) =>
      this.request<VolumesGetByIdData, any>({
        path: `/apps/${appName}/volumes/${volumeId}`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Volumes
     * @name VolumesUpdate
     * @request POST:/apps/{app_name}/volumes/{volume_id}
     * @response `200` `VolumesUpdateData` OK
     * @response `400` `ErrorResponse` Bad Request
     */
    volumesUpdate: (
      appName: string,
      volumeId: string,
      request: UpdateVolumeRequest,
      params: RequestParams = {}
    ) =>
      this.request<VolumesUpdateData, ErrorResponse>({
        path: `/apps/${appName}/volumes/${volumeId}`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Volumes
     * @name VolumeDelete
     * @request DELETE:/apps/{app_name}/volumes/{volume_id}
     * @response `200` `VolumeDeleteData` OK
     */
    volumeDelete: (
      appName: string,
      volumeId: string,
      params: RequestParams = {}
    ) =>
      this.request<VolumeDeleteData, any>({
        path: `/apps/${appName}/volumes/${volumeId}`,
        method: "DELETE",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Volumes
     * @name VolumesExtend
     * @request PUT:/apps/{app_name}/volumes/{volume_id}/extend
     * @response `200` `VolumesExtendData` OK
     */
    volumesExtend: (
      appName: string,
      volumeId: string,
      request: ExtendVolumeRequest,
      params: RequestParams = {}
    ) =>
      this.request<VolumesExtendData, any>({
        path: `/apps/${appName}/volumes/${volumeId}/extend`,
        method: "PUT",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Volumes
     * @name VolumesListSnapshots
     * @request GET:/apps/{app_name}/volumes/{volume_id}/snapshots
     * @response `200` `VolumesListSnapshotsData` OK
     */
    volumesListSnapshots: (
      appName: string,
      volumeId: string,
      params: RequestParams = {}
    ) =>
      this.request<VolumesListSnapshotsData, any>({
        path: `/apps/${appName}/volumes/${volumeId}/snapshots`,
        method: "GET",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Volumes
     * @name CreateVolumeSnapshot
     * @request POST:/apps/{app_name}/volumes/{volume_id}/snapshots
     * @response `200` `CreateVolumeSnapshotData` OK
     */
    createVolumeSnapshot: (
      appName: string,
      volumeId: string,
      params: RequestParams = {}
    ) =>
      this.request<CreateVolumeSnapshotData, any>({
        path: `/apps/${appName}/volumes/${volumeId}/snapshots`,
        method: "POST",
        ...params,
      }),
  };
}
